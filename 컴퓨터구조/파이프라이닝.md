# 파이프라이닝

## 오늘날 왜 단일 사이클 구현은 사용되지 않는가?
* 최장 경로
  * 적재 명령어
  * 명령어 메모리 + 레지스터 파일 + ALU + 데이터 메모리 + 레지스터 파일
  * 클럭 사이클 시간 결정 -> 매우 길다.
* 단일 사이클 구현의 장단점
  * CPI = 1 이지만 클럭사이클이 너무 길어서 성능이 나쁘다
  * 간단하고 이해하기 쉽다.
* 가변 클럭 사이클 시간
  * 성능은 좋지만 구현 불가능
* 성능 개선 방법
  * 다중 사이클 (multicycle) 구현
  * **파이프라이닝**

## 파이프라이닝에 대한 개관
### 파이프라이닝
* 여러 명령어가 중첩되어 실행되는 구현 기술
* 명령어 수준 병렬성을 활용
* 각 명령어의 실행시간은 개선하지 못하나, **처리량(throughput)** 개선

## 명령어 실행의 다섯 단계
1. 명령어 메모리에서 명령어 인출
2. 명령어를 해독하는 동시에 레지스터 읽기
> MIPS 명령어는 형식이 규칙적이므로 레지스터 읽기과 명령어 해독이 동시에 가능
3. 연산 수행 또는 주소 계산
4. 데이터 메모리 내의 피연산자에 접근
5. 결과 값을 레지스터에 쓰기

## 예제 : 단일사이클 대 파이프라인 성능 비교
* lw, sw, add, sub, and, or, slt, beq 구현
* 주요 기능 유닛의 동작 시간
  * 메모리 접근과 ALU 연산 : 200ps
  * 레지스터 파일 읽기와 쓰기 : 100ps
* 단일 사이클과 파이프라인에서 명령어 사이의 평균 시간 비교

| Instruction class | Instruction Fetch | Register read | ALU operation | Data access | Register write | Total time |
|--------|--------|--------|--------|--------|--------|--------|
| Load word (lw) | 200ps | 100ps | 200ps | 200ps | 100ps | 800ps |
| Store word (sw) | 200ps | 100ps | 200ps | 200ps |  | 700ps |
| R-format (add, sub, AND, OR, slt) | 200ps | 100ps | 200ps |  | 100ps | 600ps |
| Branch (beq) | 200ps | 100ps | 200ps |  |  | 500ps |

## 파이프라인의 성능
* 파이프라인 클럭의 속도
  * 가장 느린 단계(stage)에 의해 결정
* 완벽하게 균형잡힌 (perfectly balanced) 파이프라인
  * 모든 단계의 처리 시간이 같은 파이프라인
  * 명령어 사이의 시간(pipelined) = 명령어 사이의 시간(nonipelined) / 파이프 단계 수
* 클럭 사이클 시간 = t, 단계수 = k인 파이프라인의 속도 향상
  * 명령어 n개를 실행할때
  ![](https://latex.codecogs.com/gif.latex?speedup%20%3D%20%5Cfrac%7Bn%20%5Ctimes%20k%20%5Ctimes%20t%7D%7B%28k-1%29%20%5Ctimes%20t%20&plus;%20n%20%5Ctimes%20t%7D%20%3D%20%5Cfrac%7Bn%20%5Ctimes%20k%20%5Ctimes%20t%7D%7Bk%20%5Ctimes%20t%20&plus;%20%28n%20-%201%29%20%5Ctimes%20t%7D)
  * 무한히 많은 명령어를 실행할 때
    speedup = k 

## 파이프라인 해저드
* 다음 명령어가 다음 클럭 사이클에 실행될 수 없는 상황
* 구조적 헤저드 (structural hazard)
  * 다른 단계에 있는 명령어들이 동시에 같은 자원을 사용하려고 하는 상황
  * 해결 방법: 해당 자원을 여러 개 설치
* 데이터 해저드 (data hazard)
  * 앞의 명령어의 결과를 사용해야 하는데, 앞의 명령어가 끝나지 않아 아직 결과를 사용할 수 없는 상황
  * 해결방법 : 파이프라인 지연 (stall), 전방전달(forwarding) 등
* 제어 헤저드 (control hazard)
  * 앞의 분기 명령어가 분기할지 안할지 몰라서 다음 명령어를 인출할 수 없는 상황
  * 해결방법 : 파이프라인 지연, 분기 예측, 지연 분기