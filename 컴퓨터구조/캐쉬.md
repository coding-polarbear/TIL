# 캐쉬의 기본

## 서론
* 캐쉬 메모리의 정의
  * 메모리 계층구조에서 프로세서와 주기억장치 사이에 잇는 것
  * 프로세서와 주기억장치 사이에 있는 작고 빠른 메모리
* 최초의 구현
  * University of Cambridge의 Scarrott 교수
* 캐시를 장착한 최초의 사용 컴퓨터
  * IBM 360/85, 1968년 1월

## 직접 사상 캐시 (Direct Mapped Cache)
* 각 메모리 위치는 캐쉬 내의 한 장소에 사상
  * 캐시 주소 (i.e 캐시 인덱스) = (블록 주소) modulo (전체 캐쉬 블록 수)
  * 전체 캐쉬 블록 수가 2^N이면,
  캐시 주소 = 메모리 주소의 하위 N 비트
  * 여러 메모리 주소가 한 캐시 블록을 공유
* 캐시 블록의 구성
  * 유효 비트(valid bit)
  * 데이터
  * 태그(tag)
    * 캐쉬 내의 워드가 요청한 것인지 아닌지를 식별하는데 필요한 주소정보
    * 캐쉬 주소 중 인덱스를 제외한 상위 부분

## 1-워드 블록 캐시
* 캐시 구성
  * 32비트 메모리 주소
  * 직접 사상 캐시
  * 캐시블록 : 1워드
    * 바이트 오프셋 : 주소의 최하위 2비트 (캐시에서 사용 x)
  * 캐시 크기 : 2^n 워드
    * 캐시 인덱스 : n비트
  * 태그 :32 - (n+2) 비트
* 캐시의 전체 비트수 : 2^n X (63 - n)

## 2^m-워드 블록 캐시
* 캐시 구성
  * 32비트 메모리 주소
  * 직접 사상 캐시
  * 캐시 블록 : 2^m 워드 
    * 블록 오프셋 : m비트
  * 캐시 블록 개수 : 2^n
    * 캐시 인덱스 : n 비트
  * 캐시 크기 : 2^(n + m) 워드
  * 태그 = 32 - (n + m + 2) 비트
* 캐시의 전체 비트 수 : `2^n X (31 - n - m 2^m X 32)

## 쓰기의 처리
* 즉시 쓰기 (write-through)
  * 캐시와 메모리에 동시에 쓰는 방식
  * 두 계층의 데이터가 항상 일치(consistent)
  * 쓰기 실패의 처리
    * 메모리에서 해당 워드가 포함된 블록을 가져와서 캐시에 넣고, 이 워드에 쓰기 수행
    * 또한 전체 주소를 사용하여 이워드만 메인 메모리에도 씀
  * 성능저하
    * 쓰기를 할 때마다 메인 메모리 접근 필요
* 쓰기 버퍼 (write buffer)
  * 메모리에 쓰이기 위해 기다리는 동안 데이터를 저장하는 큐
  * 캐시와 쓰기 버퍼에 쓰고 나면, 프로세서는 즉시 수행 계속
  * 쓰기 버퍼가 꽉 차 있을때만 정지
* 나중 쓰기 (write-back)
  * 새로운 값은 일단 캐시에만 쓰고, 나중에 캐시에 쫓겨날 때 메모리에 씀
  * 갱신 비트 (dirty bit 또는 modified bit)
  * 즉시 쓰기보다 성능이 좋지만, 구현이 어려움