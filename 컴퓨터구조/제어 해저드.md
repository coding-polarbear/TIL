# 제어헤저드

## 제어 해저드 (control hazard) 또는 분기 해저드 (branch hazard)
* 인출한 명령어가 필요한 명령어가 아니기 때문에 적절한 명령어가 적절한 클럭 사이클에 실행될 수 없는 사건
* 명령어 주소의 흐름이 파이프라인이 기대한 것과 다르기 때문에 발생
* 매 클럭마다 명령어 인출할때 분기명령어의 경우 인출한 다음 명령어를 바로 알 수 없음

## 해결 방법
1. 분기 시 지연 (stall on branch)
2. 분기 예측 (branch prediction)
3. 지연 분기 (delayed branch)

### 해결방법 1 - 분기 시 지연
* 분기 시 지연 (stall on branch)
  * 분기 여부가 결정될 때 까지 다음 명령어 인출을 연기
  * 분기 명령어가 나올 때마다 파이프라인 지연
  * 분기가 MEM 단계에서 실행될 때, 3 클럭 분기 손실 (branch penalty)

```mips
beq $1, $3, 28
and $12, $2, $5
or $13, $6, $2
add $14, $2, $2
```

| | IF | ID | EX | MEM | WB |
| ----- | ----- | ----- | ----- | ----- | ----- |
| CC1 | beq | | | | | 
| CC2 | (bubble) beq | | | |
| CC3 | (bubble) | (bubble) | beq | | |
| CC4 | (bubble) | (bubble) | (bubble) beq | |
| CC5 | lw | (bubble) | (bubble) | (bubble) | beq |
| CC6 | sub | lw | (bubble) | (bubble) | (bubble) |
| CC7 | sw | sub | lw | (bubble) | (bubble) |
| CC8 | slt | sw | sub | lw | (bubble) |
| CC9 | addi | slt | sw | sub | lw |


#### 분기에 따른 지연 줄이기
* 분기 성능 향상 방법
  * 다음 Pc 값을 MEM 단계가 아니라 ID 단계에서 선정
  * IF 단계에 있는 명령어 한 개만 쓸어내리면 됨
  * 분기 손실 = 1 클럭 사이클
* 데인터 패스 수정
  * 분기 목적지 주소 계산과 분기 조건 검사를 ID 단계에서 실행
  1. 분기 덧셈기를 ID단계로 이동
  2. ID단계에 비교기 추가
* 제어 신호의 추가
  * IF.Flush
  * IF/ID 파이프라인 레지스터의 명령어 필드를 0으로 만듬
  * 인출된 명령어를 `nop`으로 바꿈

### 해결 방법 2 - 분기 예측
* 파이프라인이 길어지면 분기 결과를 결정하는데 오래 걸림 -> 분기 손실이 너무 큼
* 분기 예측
  * 실제 분기 결과가 확인될 때까지 기다리는 대신, 분기 결과를 가정하고 그 가정 하에 파이프라인을 진행해 나가는 분기 해저드 해결 방버
  * 분기 결과를 예측
    * 예측이 맞으면 지연 없이 진행
  * 예측 실패 손실 (misprediction penalty)
    * 예측이 틀렸을 때만 생기는 파이프라인 지연

#### 정적 및 동적 분기 예측 방법
* 정적 분기 예측
  * 프로그램 실행 전에 분기 방향 예측
  * 분기 명령어 자체에 대한 정보만으로 예측
  1. 분기가 일어난다고 가정
  2. 분기가 일어나지 않는다고 가정
  3. Opcode에 따라 예측
  4. 분기 방향에 따라 예측
* 동적 분기 예측
  * 실행 시 수집한 정보를 이용하여 분기 방향 예측
  * 프로그램을 실행하면서 하드웨어가 분기 이력을 기록
  1. 분기 예측 버퍼 (Branch prediction buffer)
  2. 연관 (correlating) 분기 예측
  3. 토너먼트 (tournament) 분기 예측
  4. 분기 목적지 버퍼 (branch target buffer)

#### 동적 분기 예측
* 동적 분기 예측 (dynamic branch prediction)
  * 실행 정보를 이용하여 실행 시에 분기 예측
  * 명령어 주소를 살펴서 지난번 실행시 분기 여부를 검사
  * 지난번과 같은 방향에서 명령어 인출
* 분기 이력표 (branch history table, BHT)
  * 분기 예측 버퍼 라고도 함
  * 분기 명령어 주소의 `하위 비트`에 의해 인덱스되는 작은 메모리
  * 예측기 (predictor) 최근에 분기가 일어났는지 아닌지를 나타내는 비트
* 분기 명령어으 ㅣ실행
  * BHT를 검사해서 분기 여부 예측
  * 다음 명령어 또는 분기 목적지에서 명령어 인출
  * 예측이 틀렸을 때는, 파이프라인을 비우고 예측방향을 바꿈

### 해결 방법 3 - 지연 분기
* 지연 분기 (delayed branch)
  * 다음 순서의 명령어를 항상 실행하고, 실제 분기는 그 명령어를 파이프라인에 넣고 나서 한 사이클 늦게 일어난다.
* 분기 지연 슬롯 (branch delay slot)
  * 지연 분기 명령어 바로 다음 슬롯
  * 컴파일러와 어셈블러는 분기 여부와 상관 없이 항상 실행되는 명령어로 채움
* 지연분기와 동적 분기 예측
  * 매 사이클마다 명령어 하나씩 내보내는 5단계 파이프라인의 경우 지연분기가 간단하면서도 효과적
  * 단계 수가 많아지고 동시에 여러 명령어를 내보내는 경우, 지연 슬롯 하나로는 충분하지 않음
  * 더 비싸지만 유연한 동적 분기 예측에 비해 지연분기를 인기를 잃어가고 있음

