# 다항식 추상 데이터 타입
## 순서 리스트
* examples
  * 한 주일의 요일 : (일, 월, 화, 수 , ..., 토)
  * 카드의 한 벌의 값 : (Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King)
  * 건물 층 : (지하실, 로비, 일층, 이층)
  * 미국의 제2차 세계대전 참전년도 : (1941, 1942, 1943, 1944, 1945)
  * 스위스의 제 2차 세계대전 참전년도 : ()
* 리스트의 형태 : (a0, a1, ..., an-1)
* 공백리스트의 예 : ()

## 순서리스트
### 순서 리스트에 대한 연산
* 리스트의 길이 n의 계산
* 리스트의 항목을 왼쪽에서 오른쪽 (오른쪽에서 왼쪽) 으로 읽기
* 리스트로부터 i번째 항목을 검색, 0 < i < n
* 리스트의 i번째 항목을 대체, 0 <= i < n
* 리스트의  i번째 위치에 새 항목 삽임, 0 <= i < n 이것은 원래 i, i+1, ..., n-1 항목 번호를 i+1, i+2, ... , n 으로 만듦
* 리스트의 i번째 항목을 제거, 0 <= i < n 이것은 원래 i+1, ..., n-1 항목 번호를 i, i+1, ..., n-2로 만듬

### 순서 리스트의 일반적인 구현
* 배열을 이용
* 문제점 : 삽입, 삭제 시 오버헤드

## 다항식
### a(x) = 3x^2+ 2x-4, b(x) = x^8 - 10x^5 -3x^3 + 1
* 계수(cofficient) : 3, 2, -4
* 지수 (exponent) : 2, 1, 0
* 차수 (degree) : 0이 아닌 제일 큰 지수

## 다항식의 합과 곱
* a(x) + b(x) = Sigma(ai + bi)xi
* a(x) * b(x) = Sigma(ai*x^i * Sigma(bj * x^j))

## 다항식 표현
* 첫번째 겾렁 : 다항식을 지수 내림차순으로 정돈

**[표현 1]**
```c++
private:
    int degree;     //degree <= MaxDegree
    float coef[MaxDegree + 1];  //계수 배열
```
* a.coef[i]는 x^(n-i)의 계수, 각 계수는 내림차순으로 저장
* 다항식의 연산을 위한 알고리즘이 간단하지만 메모리 낭비가 심함

**[표현 2]**
```C++
private:
    int degree;
    float *coef;
```

* 생성자를 Polynomial에 추가
```C++
Polynomial::Polynomial(int d) {
    degree = d;
    coef = new float[degree + 1];
}
```
* 희소 다항식에서 기억 공간 낭비
ex) 다항식 x^1000 + 1
-> coef에서 999개의 엔트리는 0

**[표현 3]**
* termArray의 각 원소는 term 타입
```C++
class Term {
    friend class Polynomial;
    private:
        float coef; //계수
        int exp; //지수
}
```

* Polynomial의 전용 데이터 멤버 선언
```C++
private:
    Term *tremArray; //0이 아닌 항의 배열
    int capacity; //termArray의 크기
    int terms; //0이 아닌 항의 수
```

## 다항식 덧셈
* c = a + b를 구하는ㄴ C++함수
* 함수 Add : a(x) (this)와  b(x)를 항별로 더하여 c(x)를 만드는 함수
  * Polynomial의 디폴트 생성자가 capacity와 terms를 각각 1과 0으로 초기화하는 것을 가정
  * 기본루프는 지수를 비교한 결과에 따라 두 다항식의 항들을 하나로 합하는 과정으로 구성

* Add 함수가 종료될때 c.capacity가 2^k로 가정 (2^k로 메모리 확장)
* 총 2^0 + 2^1 + 2^2 + ... + 2^(k-1) = 2^k - 1만큼 복사
* 2^(k-1) < c.term (마지막으로 복사된 수 보다 현재 항 수가 큼)
* c.term <= m + n (두 다항식의 합은 m+n 보다 항 수가 작거나 같음)
* 그러므로 2&(k-1) < m+n
* 양변에 2를 곱하고 -1을 수행
* 2^k -1(복사된 수) < 2(m+n) - 1
* 따라서 2^k - 1 = O(m + n)

## 희소 행렬 (Sparse Matrics)
### a[m][n]
* m X n 행렬 a
  * m : 행의 수
  * n : 열의 수
  * m X n : 원소의 수
* 희소 행렬 (sparse Matrix)
  * 0이 아닌 원소수 / 전체 원소수 << small
   > 0이 아닌 원소만 저장한다면 시간과 공간 절약

* 행렬에 대한 연산
  * Creation (생성)
  * Transpose (전치)
  * Addition (덧셈)
  * Multiplication (곱셈)

## 행렬의 전치
### 원래 행렬의 각 행 i에 대해서 원소 (i, j 값)을 가져와서 전치 행렬의 원소 (j, i 값)에 저장.
ex)
```
for (각 i행에 대해)
    원소(i,j 값)을 원소 (j, i값) 으로 저장
    (0,0, 15) -> (0, 0, 15)
    (0, 3, 22) -> (3, 0, 22)
    (0, 5, -15) -> (5, 0, -15)
    (1, 1, 11) -> (1, 1, 11)
```
> 올바를 순서 유지를 위해 기존 원소를 이동시켜야 하는 경우 발생

## 스트링 추상 데이터 타입
* 문자열 (string) : S = s0, ..., sn-1의 형태
  * si = 문자 집합의 원소
  * n = 0 : 공백 또는 널 문자열
* 연산
  * 새로운 공백 스트링 생성
  * 스트링 읽기 또는 출력
  * 두 스트링 접합 (concatenation)
  * 스트링 복사
  * 스트링 비교
  * 서브스트링을 스트링에 삽입
  * 스트링에서 서브스트링 삭제
  * 스트링에서 특정 패턴 검색
* ADT 2.5

## 함수 Find
* 두 개의 스트링과 pat
* pat이 s에서 탐색할 패턴
* 호출 형식 : s.Find(pat)
* pat과 i번째 위치에서 시작하는 s의 부분문자열 부하될 때 인덱스 i를 반환
* pat이 공백이거나 s의 부분문자열이 아닌 경우 -1을 반환
* LengthP : 패턴 pat의 길이
* LengthS : 스트링 s의 길이
* s에서 LengthS - LengthP의 오른쪽은 pat과 매치될 문자가 충분하지 않으므로 고려하지 않아도 됨

