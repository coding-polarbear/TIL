# 시스템 생명 주기 (System Life Cycle)
## 요구사항 (requirement)
* 프로젝트들의 목적을 정의한 명세들의 집합
* 입력과 출력에 관한 정보를 기술

## 분석 (analysis)
* 무제들을 다룰 수 있는 작은 단위들로 나눔

## 설계(design)
* 추상 데이터 타입 (abstract data type) 생성
* 알고리즘 명세와 설계 기법 고려

## 정제와 코딩 (refinement and coding)
* 데이터 객체에 대한 표현
* 수행되는 연산에 대한 알고리즘 작성

## 검증 (verification)
* 정확성 증명 (correctness proof)
  * 수학적 기법들을 이용해서 증명
* 테스트 (testing)
  * 프로그램의 정확한 수행 검증
  * 프로그램의 성능 검사
* 오류 제거 (error removal)
  * 독립적 단위로 테스트 후 전체 시스템으로 통합


# 객체 지향 설계

## 구조적 프로그래밍 설계와의 비교
* 유사점
  * 분할 - 정복 기법 : 복잡한 문제를 여러개의 단순한 부분으로 나누어 각각을 개별적으로 해결
* 차이점
  * 과제 분할 방법

# 알고리즘적 분해와 객체지향적 분해
## 알고리즘적 분해 (함수작 분해)
* 고전적 프로그래밍 기법
* 소프트웨어를 기능적 모듈로 분해
* Pascal의 프로시저, FORTRAN의 서브프로그램, C의 함수
## 객체지향적 분해
* 응용 분야의 개체를 모델링하는 객체의 집합
* 소프트웨어의 재사용성 향상

# 객체지향 프로그래밍의 기본 정의와 개념

## 객체 (Object)
* 계산을 수행하고 상태를 갖는 개체
* 데이터 + 절차적 요소

## 객체지향 프로그래밍 (object-oriented programming)
* 객체는 기본적인 구성 타입 (building block)
* 각 객체는 어떤 타입 (클래스)의 인스턴스(instance)
* 클래스는 상속 (inheritance) 관계로 연결됨

# 데이터 추상화와 캡슐화

## 데이터 캡슐화 (data encapsulation)
* 정보 은닉 (information hidnig)
* 외부로부터 데이터 객체의 자세한 구현을 은닉

## 데이터 추상화 (data abstraction)
* 객체의 명세 (specification)와 구현 (implementation)을 분리
* 무엇(what)과 어떻게(how)를 명확하게 구분

# 데이터 타입

## 데이터 타입 (data type)
* 객체(object)들과 이 객체들에 대한 연산 (operation)의 집합

## C++의 데이터 타입
* 기본 데이터 타입
  * char, int, float, double 등
  * 타입 수식어 : short, long, signed, unsigned
* 파생 데이터 타입
  * 포인터(pointer) 타입, 참조(reference) 타입
* 데이터를 묶어주는 구조    
  * 배열 (array)
  * 구조체 (struct)
  * 클래스 (class)

## 추상 데이터 타입 (abstract data type : ADT)
> 객체의 표현과 구현으로 분리된 방식으로 구성된 데이터 타입

# 데이터 추상화와 데이터 캡슐화의 장점

* 소프트웨어 개발의 간소화
  * 복잡한 작업을 부분 작업들로 분해
* 테스트와 디버깅
  * 각 부분 작업을 독자적으로 테스팅, 디버깅
* 재사용성
  * 자료구조에 대한 코드와 연산을 추출해서 다른 소프트웨어 시스템에서도 사용
* 데이터 타입의 표현에 대한 수정
  * 데이터타입이 같은 연산 제공, 같은 기능 제공 -> 프로그램의 나머지 부분에 영향을 주지 않음
  * 데이터 타입의 내부 구현에 직접 접근하는 연산들만 수정

# 알고리즘 명세

## 알고리즘
> 특정 작업을 수행하는 명령어들의 유한집합

## 알고리즘의 요건
* 입력 : 외부에서 제공되는 데이터가 0개 이상
* 출력 : 적어도 한 개 이상의 결과 생성
* 명확성 : 각 명령은 명확하고 모호하지 않아야 함
* 유한성 : 알고리즘대로 수행하면 어떤 경우에도 반드시 종료
* 유효성 : 반드시 실행(구현) 가능해야 함

## 알고리즘 기술 방법
* 자연어
* 흐름도 (flow chart)
* C++언어

# 순환 알고리즘
* 직접 순환 (direct recursion) : 함수가 그 수행이 완료되기 전에 자기 자신을 다시 호출
* 간접 순환 (indirect recursion) : 호출 함수를 다시 호출하게 되어 잇는 다른 함수를 호출

# 성능 분석과 측정

## 프로그램의 평가 기준
* 우리가 원하는 작업을 하는가?
* 원래 작업의 명세에 부합해서 정확히 작동하는가?
* 문서화가 되어 있는가?
* 논리적 작업 단위를 수행하는 기준으로 함수가 생성되었는가?
* 코드가 읽기 쉬운가?

## 성능 평가 (peformance evaluaton)
* 성능 분석 (performance analysis)
  * 사전 예측
* 성능 측정 (performance measurement+)
  * 이후 검사

# 공간복잡도

## 공간복잡도 (space complexity)
* 프로그램을 실행시켜 완료하는 데 필요한 메모리 양
* 고정 부분
  * 보통 명령어 공간, 단순 변수, 집합체, 상수를 위한 공간
* 가변 부분
* 특정 문제의 인스턴스에 따라 크기가 달라지는 변수, 순환 스택 공간

프로그램 P의 공간 요구 `S(P) = c + Sp`
c : `상수`
Sp : `인스턴스 특성`

# 시간복잡도
> 프로그램을 완전히 실행시키는데 필요한 시간

* T(P) = 컴파일 시간 + 실행 시간 (tp(인스턴스 특성))

