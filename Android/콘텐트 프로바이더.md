# 콘텐트 프로바이더
* 여러 앱 간에 데이터를 공유할 필요가 있을 때 사용
* 데이터 소스가 굳이 DB일 필요는 없으며 파일이든 네트워크를 통해서 가져오는 값이든 상관 없이 모두 콘텐트 프로바이더의 데이터 소스가 될 수 있음.
* 다만 API가 DB를 데이터 소스로 사용하는 것에 더 맞게 디자인되어있음.
* `ContentProvider`에 접근하는 것은 `ContentResolver`를 통해서만 가능함.
* `ContentResolver`는 `Context`의 `getContentResoplver()` 메소드로 구할 수 있음.
* `ContentResolver`는 일종의 프락시로, 해당하는 `Uri`의 `ContentProvider`를 찾는 역할을 함.
* `ContentResolver`는 추상클래스로 실제 구현채는 `ContextImpl`의 내부 클래스인 `ApplicationContentResolver`

## 로컬 프로세스에서 콘텐트 프로바이더 적용 기준
* 개발자 가이드엣거는 로컬 프로세스에서만 데이터가 쓰인다면 콘텐트 프로바이더를 사용하지 말 것을 권장함.

## 로컬 프로세스에서 콘텐트 프로바이더를 사용하는 장점.
* `ContentProvider`의 메소드 시그니처를 따라야 하므로 여러 DB를 사용하더라도 API의 일관성을 유지할 수 있음. 이러한 일관성은 다른 프로젝트에 적용할 때도 장점이 될 수 있음.
* `CursorLoader`. `AsyncQueryHandler` 와 같은 클래스들이 콘텐트 프로바이더의 Uri가 전달되어야 작동함.
* 1개의 앱에서도 프로세스가 분리될 수 있음.
  * 앱 프로세스에 콘텐트 프로바이더를 두고, 서비스 프로세스에서 `ContentResolver`를 통해서 콘텐트 프로ㅜ바이더에 접근하면 유일한 DB 헬퍼를 유지할 수 있음.

## 로컬 프로세스에서 콘텐트 프로바이더를 사용하는 단점.
* DB에 직접 접근하는 것에 비해서 코드가 복잡함.
* 프락시인 `ContentResolver`를 거쳐야 하기 때문에 직접 DB를 접근하는 것에 비해 속도가 느림.
* `groupBy`, `having`, `limit` 같은 파라미터를 `ContentResolver`의 메소드에 전달 할 수 없음. 필요한 경우 `Uri`나 쿼리 파라미터에 억지로 끼워넣어서 전달해야 함
* `ContentResolver`를 통하므로 별도의 공개 메소드를 만들어도 접근할 수 없음.

## 결론
* 로컬 프로세스에서 콘텐트 프로바이더는 꼭 필요할 때만 쓰는 것이 좋음.
* DB에 직접 접근하는 코드에서도 메소드 시그니처를 `ContentProvider`와 유사하게 만들면, 이후에 수월하게 변경할 수 있음.
* 프로세스가 분리되거나 다른 앱에서 DB에 접근해야 한다면, 필요한 부분만 콘텐트 프로바이더를 제공해서 `DB접근(내부용) + 콘텐트 프로바이더(외부용)` 으로 구성하는 것도 가능한 방법.