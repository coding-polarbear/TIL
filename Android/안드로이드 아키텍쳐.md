# 안드로이드 아키텍쳐
> 오랜만에 Return to Base

![안드로이드 아키텍쳐](https://www.tutorialspoint.com/android/images/architecture.jpg)

### 애플리케이션 
> 안드로이드에서 제공하는 선탑재 기본 앱(홈, 카메라, 전화, 브라우저 등) 과 다운로드해서 설치하는 일반 앱

* 애플리케이션은 애플리케이션 프레임워크 스택 위에서 동작
* 단말에 깔린 기본 앱과 우리가 만드는 앱은 동일한 레벨
* 선탑재된 기본 앱은 시스템 권한을 사용할 수 있고, 프로세스 우선순위를 높일 수 있음 

#### 프로세스 우선순위
> 단말기에 메모리가 부족한 상황에서 시스템에서 강제로 종료시키는 기준

### 애플리케이션 프레임워크
> 안드로이드 OS 위에서 애플리케이션의 기반이 되는 기본 구조

* 앱에서 액티비티 인스턴스를 생성하고 상황에 맞는 생명주기 메소드를 호출하는 역할
* 설정된 언어에 맞게 리소스를 찾아오는 역할

개발자가 이러한 각각의 행동을 직접 하지 않아도 되는 이유는 애플리케이션 프레임워크가 이작업을 알아서 해주기 때문

각각의 `Managaer`가 애플리케이션 프레임워크의 역할을 한다.

* Activity Manager : 액티비티를 생성해서 생명주기 메소드를 호출
* Resource Manager :  리소스를 찾아주는 역할

##### 네이티브 C / C++ 코드 사용
* 여러 Manager는 대부분 JAVA로 작성
* 이 가운데 하드웨어 제어나 빠른 속도가 필요한 것들은 내부적으로 JNI를 연결해서 네이티브 `C / C++` 코드를 사용하기도 함.
ex) `Telephony Manager`, `Location Manager`, `Resource Manager`

##### 씬 클라이언트와 서버
> 앱 프로세스는 `씬 클라이언트 (Thin Client)` 이다.

* 앱 프로세스는 컴포넌트 탐색, 액티비티 스택관리, 서비스 목록 유지, ANR 처리 등을 직접 하지 않음
* 서버인 `system_server` 프로세스에 모두 위임하고 컴포넌트 실행 등 최소한의 역할만 수행
* `system_server`는 여러 앱을 통합해서 관리하는 `통합 문의 채널`

##### 시스템 서비스 접근
* 여러 `Manager` 서버는 시스템 서비스 형태로 존재
* 앱에서 접근할때에는 `Context`의 `getSystemService(String name)` 메소들 호출하여 사용
* `system_server`라는 별도 프로세스에서 실행되므로 앱에서는 시스템 서비스에 접근할 때 `Binder IPC`를 이용한 프로세스 간 통신이 필요

### 안드로이드 런타임
> 달빅 가상 머신 / ART는 자바 / C / C++ 로 작성됨

##### 코어 라이브러리
> 코어 라이브러리는 커널을 래핑하거나 추가 기능을 제공하는 역할을 수행

### 라이브러리
**대표적인 Native Library**
* `Bionic`이라는 커스텀 C 라이브러리 (`libc`)
* `WebKit` / `SQLite` / `OpenGL` 같은 기능 라이브러리
* 네이티브 시스템 서비스인 `Surface Manager`, `Media Framework`


### 리눅스 커널
> 안드로이드의 커널은 리눅스 커널을 기반으로 불필요한 것 (X-window, 표준 리눅스 유틸리티 등)을 제거하고 확장배치 한 것

##### Binder IPC
* 프로세스간 통신에 사용
* IPC : 하부 메커니즘
* RPC : IPC의 용도 (리모트 콜)

ex) `서비스`와 `Content Provider`는 바인더를 이용하여 다른 프로세스에 접근 가능

##### Binder Thread
> 앱 프로세스에는 `Binder Thread`라는 네이티브 스레드 풀이 있고, 최대 16개까지 스레드가 생성