# 생명주기
## 생명주기 다이어그램
### 다른 액티비티에 가리는 경우
* `onPause` -> `onStop` -> `onResume` -> `onRestart` -> `onStart`
  
### 우선순위가 더 높은 앱이 메모리를 확보
* 우선순위가 더 높은 앱이 메모리가 필요하다면 앱은 언제든지 종료될 수 있기 때문에 `onStop()`, `onDestroy()` 메소드는 반드시 실행된다는 보장이 없음
* 반드시 실행된다는 보장이 없기 때문에 `onStop`과 `onDestroy`는 상대적으로 오버라이딩 하지 않을 때가 많음.
* 리소스를 안전하게 정리하는게 필요할 때는 `onStop()`이나 `onDestroy()`에 안전장치로 코드를 추가하기도 함.

### 시스템에 의한 액티비티 제거
* `onDestroy()`까지 불리는 것은 `finish()`가 호출될 때만으로 이해하기 쉽지만 시스템에 의해서 액티비티가 제거될 때에도 호출됨.
* 여러 태스크를 사용하는 앱에서 메모리가 많이 사용될 때 발생하는 문제
* 앱에서 하나의 태스크만 사용할 때에는 `OutOfMemoryException`이 발생하지만, 앱에서 여러가지 태스크를 사용한다면 `OutOfMemoryError`가 발생하기 전에 포그라운드 태스크를 우선시하면서 백그라운드 태스크에서 액티비티를 종료.
* 이것이 시스템에 의한 액티비티 제거 방식으로, 태스크의 액티비티 목록이 유지된다고 가정하면 안됨.
* 액티비티 개수나 액티비티 목록을 메모리에 유지하는 방식은 가능하면 사용하면 안되고, 사용하더라도 주의해야함.

## 생명주기 메소드 호출 시점

### 시작할 때
`onCreate()` -> `onStart()` -> `onResume()`

### 화면 회전할 때 (가로 / 세로)
`onPause()` -> `onStop()` -> `onDestroy()` -> `onCreate()` -> `onStart()` -> `onResume()`

### 다른 액티비티가 위에 뜰 때 / 전원 키로 화면 OFF 할때 / 홈키
`onPause()` -> `onStop()`

### 백 키로 액티비티 종료
`onPause()` -> `onStop()` -> `onDestroy()`

### 백 키로 기존 액티비티에 돌아올 때 / 홈 키로 나갔다가 돌아올 때
`onRestart()` -> `onStart()` -> `onResume()`

### 다이얼로그 테마 액티비티나 투명 액티비티가 위에 들 때
`onPause`

### 액티비티 라이프 타임
Activity API 문서를 보면 3가지 라이프타임(`lifetime`) 으로 구분됨.

* 전체 라이프타임 : `onCreate()` -> `onDestroy()`
* 가시(`visible`) 라이프타임 : `onStart()` -> `onStop()`
* 포그라운드 라이프타임 : `onResume()` -> `onPause()`

from < 라이프타임 < to관계

* setContentView의 결과물은 onResume() 이후에 보임


### 추가로 생명주기 메소드가 불리는 시점 확인
* `onCreate()`에서 `finish()`를 호출하면 다른 생명주기를 거치지 않고 곧바로 `onDestroy()`를 실행함.
* `onActivityResult()`는 `onResume()`에서도 최신 데이터를 업데이트해야 할 때, 실행 순서에 주의해야 함.

### onPostCreate()나 onPostResume() 같은 메소드는 앱에서 권장하지 않음.
* 생명주기 사에에서 뭔가를 할 수도 있음.
* 시스템에서 초기화를 위해서 사용하는 것으로 앱에서 쓰는 것은 권장하지 않음

## 액티비티 시작 메소드

### 액티비티를 시작하는 메소드
* 액티비티를 시작하는 방법은 `startActivity()`와 `startActivityForResult()`를 호출하는 것.
* `startActivity()`는 `Context`의 메소드이기 때문에 `Activity` 뿐만 아니라 `Service`, `BroadCastReceiver`, `Application` 어디서든 `startActivity()`를 실행할 수 있음.
* 컴포넌트가 아니더라도 `Context`가 전달된 곳이라면 어디에서든 `startActivity()`를 실행할 수 있음.
* `startActivityForResult()`는 `Activity`의 메소드이기 때문에 `Activity`끼리만 데이터를 주고받을 수 있음.
* `startActivity()`는 피호출자에게 데이터를 전달하기만 함.
* `startActivity()`로 시작된 피호출자에서 `getCallingActivity()`와 `getCallingPackage()` 메소드는 null을 리턴함.
* `startActivityForResult()`는 다르게 동작함.

### getCallingActivity()와 getCallingPackage() 메소드
* 피호출자에서 `getCallingActivity()`와 `getCallingPackage()` 메소드는 호출자의 정보를 리턴함.
* 호출자에 따라 다르게 처리할 필요가 있는 경우 구분을 위해 사용할 수 있음.

### requestCode에는 0 이상의 값을 넣음.
* `startActivityForResult(Intent intent, int requestCode)` 메소드 시그니처에서 requestCode 파라미터에는 `0` 이상의 값을 넣어야 함.

### 동일한 태스크에 있을 때만 유효
* 호출자와 피호출자가 다른 태스크에 속해 있다면 `onActivityResult()`에서 결과값을 다시 받을 수 없음.

### setResult() 메소드는 finish() 전에 호출
* 결과를 돌려주는 피호출자에서는 `finish()` 메소드 전에 `setResult()` 메소드를 호출해야 함. 
* 그래야만 `resultCode`와 `data`가 호출자에 전달됨.

### resultCode는 RESULT_OK와 RESULT_CANCELED를 주로 사용
* `setResult()` 메소드를 호출하지 않으면 `resultCode`는 기본 값이 `RESULT_CANCELED(상수 0)`가 전달됨
* 일반적으로 `RESULT_OK(상수 -1)` 값을 넣지만, 원하는 정수 값을 임의로 전달해도 됨

### Intent.FLAG_ACTIVITY_FORWARD_RESULT 플래그
* 액티비티를 A -> B -> C 순서대로 호출하고 B에서 C로 넘어갈때 B를 종료하고 C를 호출할때, C의 `setResult()`는 액티비티 A에 전달되지 않음.
* resultCode가 `RESULT_CANCELD`가 되면서 data는 null이 됨.
* 이 경우 값을 전달받기 위해서는 `ActivityB`에서 `startActivity()`로 `ActivityC`를 시작하면서 `Intent`에 `Intent.FLAG_ACTIVITY_FORWARD_RESULT` 플래그를 추가해야 함.
* 이 플래그는 `startActivityForResult()`에서 쓰이면 예외를 발생시킴.
```
android.util.AndroidRuntimeException: FORWARD_RESULT_FLAG used while also requesting a result
```

* 