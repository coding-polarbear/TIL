# 서비스 재시작 방식.md
* 가용 메모리가 낮거나 포커스를 갖고 있는 액티비티의 시스템 리소스를 복구해야할 때 안드로이드 시스템은 서비스를 강제 종료시킬 수 있음.
* 스타티드 서비스는 강제 종료 후 가능한 한 빨리 시스템에서 서비스를 재시작함.
* 서비스가 언제 재시작하는지, 재시작하는 조건은 무엇인지 알아야 서비스를 안정적으로 다룰 수 있음.

## onStartCommand() 메소드의 리턴 상수
* `START_NOT_STICKY` : 강제 종료 되면 재시작 하지 않음.
  * 명시적으로 `startService()`를 실행할 때만 의미있는 작업에 사용
* `START_STICKY` : `onStartCommand()`의 기본 리턴 값.
  * 정상적으로 종료되지 않았을 때 재시작함.
  * 재시작 시에는 다시 `onStartCommand()`를 호출하는데 이때 Intent의 파라미터가 null로 전달됨
  * `START_STICKY`는 전달된 Intent를 사용하지 않고 내부 상태 변수만 사용하는 서비스에 적합함.
* `START_REDELIVER_INTENT` : 재시작하면서 `onStartCommand()`에 Intent를 다시 전달하여 실행
  * 어떻게든 파라미터를 가지고 실행해야 하는 서비스가 이에 해당함

## 펜딩 서비스 재시작
* 액ㅌ티비티를 시작하기 위해서 앱 아이콘을 클릭하면, 첫 프로세스가 시작될 때 `Application`의 `onCreate()` 메소드에서 `startService()`를 실행해도 `MessageQueue`의 순서상 액티비티가 먼저 시작되고 그 뒤에 서비스가 시작됨
* 이때 액티비티의 `onCreate()` 메소드가 크래시를 유발하면, 프로세스는 죽지만 `ActivityManagerService`에서 `Pending Service`를 실행하기 위해서 다시 프로세스를 띄움.
* 프로세스가 뜰 때 액티비티는 띄우는 대상이 아니므로 `Application`을 생성한 이후에 바로 서비스만 시작함.

## 불필요하게 재시작되지 않게 함.
* 재시작 제어 방식도 중요하지말 불필요하게 재시작하지 않는 것도 중요함.
* 서비스를 정상적으로 종료하지 않으면 작업이 다 끝났는데도 서비스를 재시작하는 경우가 있음.
* `stopService()` : 사용 빈도가 높지 않음. 권장되는 방법은 아님.
* `stopSelf()` : 실제로 자주 사용
  * context의 `stopService()`와 역할이 동일하지만 Service 내에서 호출한다는 것이 다름.
  * 서비스에서 할 일이 끝났으면 백그라운드 스레드든 아니든 `stopSelf()`를 활용하여 서비스를 명시적으로 종료함.
  * 이때  Service는 `onDestroy()`까지 실행함.
* 만약 `stopSelf()`가 실행되지 않은 상태에서 계속 남아 있다면, 의도하지 않게 재시작하는 일이 생길 수도 있음.