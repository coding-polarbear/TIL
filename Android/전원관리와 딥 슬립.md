# 전원 관리와 딥 슬립
* 모바일 단말은 상시 전원이 차단된 상태로 오랜 시간 사용해야 하므로, 전원 관리는 안드로이드 플랫폼의 중요한 이슈.
* 안드로이드의 전원 관리 매커니즘은 젤리빈 API 레벨 17까지는 `wakelock, early suspend, late resume` 방식을 사용했었지만, 리눅스 메인 커널과 통합하는 과정에서 (커널 버전 3.4) `autosleep, wakeup sources`로 변경됨.
* 내부적으로 방식이 바뀌었지만 앱 개발에서는 동일하게 `WakeLock`을 잡고 해제하는 코드를 그대로 사용하면 됨.
* 상시 전원이 연결된 데스크탑과는 달리 모바일 기기에서는 꺼져 있는 상태를 기본으로 하고 `(sleep)` `WakeLock`을 통해 필요할 때만 ON시켜서 사용하는 것이 특징
* 슬립 상태에 들어가면 LCD, backlight, 카메라, 각종 센서 등의 전원이 차단되고 CPU도 전력 상태로 들어감.

## 슬립? 딥 슬립?
* 결론적으로 슬립과 딥슬립은 동일함.
* 슬립에서 깨우는 데 소요되는 시간에 따라 `deep sleep`, `deeper sleep` 으로 상세하게 구분되기도 함.
* 슬립보다 딥 슬립이라고 언급하는 것이 개념을 이해하는 데 도움이 되기 때문에 `딥 슬립` 이라는 표현이 더 자주 쓰임.
* 모바일 단말기에서는 딥 슬립을 흔하게 볼 수 있음.
* 딥 슬립 상태에서 가장 신경써야 하는 것은 CPU 슬립.
* 딥 슬립 상태에서는 당연히 코드 실행이 중지됨.
* 슬립할 때에는 메소드가 실행중이더라고 잠들기 때문에 코드 실행이 도중에 멈추기도 함.

## 딥 슬립 관련 API
* `SystemClock.elapsedRealtime()` : 부팅 이후 경과 시간 (딥 슬립 상태를 포함)을 리턴. 
* `SystemClock.uptimeMills()` : 부팅 이후 경과 시간에서 딥 슬립 상태에 있는 시간을 뺀 `잠들지 않은 시간`을 리턴.
* `elapsedRealtime()`에서 `uptimeMills()`를 뺀 시간이 딥 슬립 상태에 있던 시간.
* 처음 부팅을 하고 나서는 두 시간이 동일하지만 화면을 껐다가 몇분 뒤에 다시 키면 두 값이 달라짐.
* `Thread.sleep(long time)` 이나 `SystemClock.sleep(long ms)` 메소드의 파라미터 값은 `uptimeMills` 시간 기준.
* `Handler`의 `postAtTime()` 메소드나  `postDelayed()` 메소드(계산을 통해 내부적으로 다시 `postAtTime()` 호출)는  `upTimeMills`를 기준으로 함.
따라서 지연시간 도중에 딥 슬립 상태에 들어갈 수 있음.
* `PowerManager`에는 `isSleep()`이나 `isDeepSleep()` 같은 메소드는 없음.
* 딥 슬립 상태에서는 메소드가 실행되지 않을 것이고, 깨어 있는 상태는 이미 딥 슬립 상태가 아니기 때문.