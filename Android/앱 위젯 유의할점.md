# 앱 위젯 유의할 점

## 메인 스레드 점유
* `onReceive()` 메소드는 당연히 메인스레드에서 실행됨.
* 따라서 여기서도 실행 시간에 주의해야 함.
* 포그라운드에서 앱을 사용하는 중에, 앱 위젯을 업데이트하기 위해 `onReceive()~가 실행된다면 UI 동작이 버벅거리는 원인이 될 수 있음.
* 만약  `onReceive()` 메소드 내에서 앱 위젯을 업데이트하기 위해 네트워크 통신이 필요하거나 DB에서 가져올 데이터가 많아 처리 시간이 많이 예상되는 경우에는 앱 위젯 갱신 작업을 서비스로 넘기고 서비스 내에서 백그라운드 스레드를 이용하여 처리해야함.
* `onReceive()` 안에서 `AsyncTask`를 실행하여 앱 위젯을 업데이트 하는 경우, `BroadcastReceiver`는 `onReceive()` 메소드가 리턴되면 프로세스가 제거될 수도 있기 때문에 실행을 보장할 수 없음.
* 결론적으로 앱 위젯을 업데이트할 때 금방 실행되는 단순한 코드가 아니라면 서비스에 넘겨서 백그라운드 스레드에서 실행하는 것을 권장함.

## 부팅 중에는 initialLayout만 보임.
* `initialLayout`은 말 그대로 초기 레이아웃.
* 이 레이아웃을 잘못 설정하면 부팅 중에 문제가 생김.
* 이때 값을 설정해놓으면 최종적으로 부팅 완료 후 데이터를 받아와서 업데이트할 때 까지 그 값을 계속해서 보여줌
* 업데이트할 내용이 있지만 바로 보여줄 수 없는 문제를 보완하기 위해서 일반적으로 `initialLayout`을 만들 때, 보기 상태를 `View.GONE`으로 설정하고, `ProgressBar`를 포함한 로딩 메시지만 기본적으로 보이게 함.

## ICS부터 기본 패딩
* ICS 이전에는 셀 경계선까지 꽉 채워서 앱 위젯이 배치되었었음.
* target SDK 버전을 14(ICS) 이상으로 하면 앱 위젯간의 구분을 확실히 하기 위해서 셀 경계와 앱 위젯 테두리 사이에 기본 패딩이 생김.
* 기본 패딩 값은 런처앱마다 다를 수 있음.
* 따라서 기존에 셀 경계선까지 꽉 차게 앱 위젯을 만들었다면 패딩 때문에 앱 위젯의 화면상의 크기가 줄어들게 되고, 제대로 보이게 하기 위해서는 레이아웃을 조정해야 함.

## 고해상도 단말에서 Bitmap 생성 시 메모리 문제
* 앱 위젯의 일반 용도는 단순한 정보를 보여주는 것.
* 앱 위젯을 클릭하면 액티비티를 띄워 세부 정보를 보여주는 식.
* 그러나 캘린더나 시간표 같은 앱은 사용자 요구에 의해 앱 위젯의 사이즈가 `4x4`나 `5x5`가 되는 경우가 있음.
* 거의 전체 화면을 사용하는 것.
* `RemoteViews` 에서 지원하는 일반적인 뷰 클래스로는 표현이 복잡해서 `Bitmap`을 사용하기도 함.

```java
Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
cianvas = new Canvas(bitmap);
canvas.drawRect(...);
canvas.drawText(...);
canvas.drawBitmap(...);
...

//remoteViews.setImageViewBitmap(R.id.image, bitmap);
File file = saveImageFile(context, bitmap);
remoteViews.setImageViewUri(R.id.image, Uri.fromFile(file));
```

* `createBitmap()` 의 세 번째 파리미터는 투명 비트맵을 생성하기 위해 `ARGB_8888`을 적용 한 것.
* 이 옵션은 픽셀당 4바이트씩 차지하느데, 최신 디바이스의 경우 해상도가 매우 높기 때문에 화면을 거의 가득 채운다고 했을 때 매우 많은 메모리를 사용해서 `OutOfMemory Exception`이 발생할 수 있음.
* 단말기의 스펙이 높아지면서 해상도도 높아지지만, 하나의 앱에서 사용 가능한 가용메모리는 비례해서 높아지지 않음.
* 이  경우에는 앱 위젯을 별도의 프로세스로 분리하는 것도 좋은 방법.