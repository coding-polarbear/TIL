# DB 락 문제
* 앱에서 SQLite를 사용할 때 가장 문제가 되는 것은 DB 락
* 간단하게 key-value 스키마라면 메인 스레드에서 쿼리를 해도 별 문제가 없지만, 일반적으로 DB 명령은 백그라운드 스레드에서 실행하는 것이 권장됨.
* DB 락 문제는 스레드간 (또는 프로세스간) 명령을 실행할 대 락을 잡은 시점이 겹치면서 발생함.

## 5가지 락 상태
* 락의 기본 원칙은, DB를 쓸 때에는 배타 락 (`exclusive lock`)을 잡고, 읽을 때는 공유 락 (`shared lock`)을 잡는 다는 것
* 배타 락은 말 그대로 다른 락을 허용하지 않고, 공유 락은 함께 공존할 수 있음.
* 락의 상태는 총 5가지가 있음.
  * `UNLOCKED` : 기본 상태. 읽기와 쓰기가 안됨.
  * `SHARED`
    * 읽기만 되고 쓰기는 안됨. 
    * 여러 프로세스가 동시에 공유 락을 가질 수 있음. 
    * 하나의 공유 락이 활성화 되어 있다면 다른 프로세스에서 쓰기를 할 수 없음. 
    * 쓰기를 위해서는 공유 락이 모두 해제될 때 까지 대기해야 함.
  * `RESERVED`
    * 프로세스가 미래 어느 시점에 쓰기를 한다는 일종의 플래그 락
    * 예약 락은 하나만 있을 수 있으며, 여러 공유 락과 공존할 수 있음.
    * 예약 락 상태에서는 새로운 공유 락을 더 잡을 수도 있음.
  * `PENDING`
    * 락이 잡고 있는 프로스세가 가능한 한 빨리 쓰기를 하려고 함.
    * 현재 모든 공유 락이 해제될 때까지 기다려서 배타 락을 가지려고 함.
    * 펜딩 락 상태에서는 새로운 공유 락을 잡을 수 없음.
  * `EXCLUSIVE`
    * 파일에 쓰기 위해서 필요하며, 오직 하나의 배타 락만 허용함.
    * 다른 락과 공존할 수 없음.
    * SQLite에서는 동시성을 높이기 위해 배타 락을 잡는 시간을 최소화 하고 있음.
    * 우리가 만드는 코드 내에서도 배타 락 구간을 줄이도록 노력해야 함.
    * 스레드 프로그래밍에서 동기화 블록을 넓게 잡지 않도록 권장하는 것과 비슷함.

## dB 락의 발생 원인
* CRUD 가운에 CUD에서 쓰기를 하면서 배타 락을 잡는 것이 문제.
* 쿼리 문장이 단순한 CUD에서는 짧은 시간만 락이 잡히기 때문에 문제가 빈번하게 발생하지는 않음.
* 가장 배타 락을 오래 잡을 수 있는 케이스는 쓰기를 한꺼번에 하는 트랜잭션

## 트랜잭션 동작 방식
* SQLite에서 트랜잭션은 지연(`deffered`), 즉시(`immediate`), 배타(`exclusive`) 3가지 동작 방식을 사용함.
* 트랜잭션 방식의 기본값은 지연임.
* `deffered`
  * 락을 가능한 뒤로 미룸.
  * 트랜잭션을 시작할 때는 락을 잡지 않음.
  * 첫 읽기 작업이 있을 때 공유 락을 잡고 첫 쓰기 작업이 있을 대 예약 락을 잡음
  * 락이 최대한 뒤로 미뤄지기 때문에 다른 프로세스나 스레드에서 DB 작업을 할 수 있음.
* `immediate`
  * 트랜잭션을 시작할 때 예약 락이 잡힘.
  * 예약 락은 2개 이상 잡힐 수 없으므로, 다른 즉시 방식 트랜잭션을 시작할 수 는 없음.
  * 그래도 다른 프로세스나 스레드에서 읽기를 할 수는 있음.
* `exclusive`
  * 트랜잭션을 시작할 때부터 배타 락이 잡힘.
  * 따라서 트랜잭션의 시작부터 끝까지 다른 프로세스나 스레드에서 DB작업을 저전혀 할 수 없음.
* 안드로이드에서 지원하는 것은 배타와 즉시방식 2가지.
* 즉시방식은 허니컴부터 지원하기 시작함.

## 코드에서 트랜잭션 사용 방법
* 기본적으로 트랜잭션을 배타 방식으로 시작함.
```java
db.beginTransaction();
try {
    ...
    db.setTransactionSuccessful();
} catch (Exception e) {
    ...
} finally {
    db.endTransaction();
}
``
* 허니콤부터 `beginTransaction()` 외에 `beginTranscationNonExclusive()` 메소드도 사용 가능하며, 즉시 방식으로 트랜잭션을 시작함.
* 결과적으로 트랜잭션에서 DB 락 문제를 조금이라도 회피하기 위해서 쓸 수 있는 방법은 단말 버전에 따라 다른 메소드를 호출하는 것

```java
if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    db.beginTransactionNonExclusive();
} else {
    db.beginTranscation();
}

try {
    ...
    db.setTranscationSuccessful();
} catch(Exception e) {
    ...
} finally {
    db.endTransaction();
}
```

## DB 락 문제 테스트의 어려움
* 사용자가 단말에서 DB락 문제가 발생한 경우 DB락을 재현하는 것이 쉽지 않음.
* 여러 단말을 가지고 다양하게 테스트해 봐도 재현이 잘 되지 않음.
* 파일 IO 성능이 좋지 않던 초기 안드로이드 단말에서는 DB 락 문제가 쉽게 드러났지만, 최신 단말에서는 누에 금방 띄지 않을 수도 있음.
* DB락 문제는 테스트를 통해 케이스별로 해결할 수 있는게 아님.

## 읽기 전용 DB 고려
* 여러 스레드에서 DB 명려을 실행할 때 `SQLiteDatabase` 인스턴스를 1개만 사용하는 방식은 인스턴스를 여러 개 사용하는 것에 비해 속도 면에서 좋지 않음.
* 여러 스레드에서 읽기만 한다면 여러 인스턴스를 사용해도 됨.
* 여러 스레드에서 읽기 전용 DB에 접근할 때 각각 별도의 `SQLiteDatabase` 인스턴스를 가지고 읽기 명령을 실행해도 DB 락 문제없이 동시 실행이 가능함.